//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) Retargetable Decompiler <info@retdec.com>
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int32_t exit(void);
int32_t exit2(void);
int32_t function_1d008784(void);
int32_t function_1d009b00(int32_t * a1);
int32_t function_1d0179b4(int32_t a1);
int32_t function_1d017efc(int32_t a1);
int32_t function_1d018514(int32_t a1, uint32_t a2);
int32_t function_1d0188a4(int32_t a1, int32_t a2, uint32_t a3, int32_t a4, int32_t a5, uint32_t a6);
int32_t function_1d019a50(void);
int32_t function_1d01b4a0(void);
int32_t function_1d01d03c(int32_t a1);
int32_t function_1d01d50c(int32_t a1);
int32_t function_1d01d59c(int32_t * a1);
int32_t function_1d01d840(int32_t * a1);
int32_t function_1d01db50(int32_t * a1);
int32_t function_1d01f688(int32_t * a1);
int32_t function_1d01f8a8(void);
int32_t function_1d01f8d4(void);
int32_t function_1d021a3c(void);
int32_t function_1d0252b0(int32_t a1, int32_t a2);
int32_t function_1d0252fc(int32_t a1, int32_t a2);
int32_t function_1d0263fc(int32_t a1, int32_t a2);
int32_t pthread_cond_destroy(int32_t * a1);
int32_t pthread_cond_destroy2(int32_t * a1);
int32_t pthread_cond_destroy3(int32_t * a1);
int32_t pthread_cond_destroy4(uint32_t a1);
int32_t pthread_cond_destroy5(void);
int32_t time(int32_t a1);

// ------------------------ Functions -------------------------

// Address range: 0x1d008784 - 0x1d008820
int32_t function_1d008784(void) {
    // 0x1d008784
    if (*(int32_t*)0xa00135c4 < 101) {
        // 0x1d008818
        return 8;
    }
    int32_t v1 = 938; // bp-24, 0x1d0087a8
    if (*(int32_t*)0xa0013654 < 3) {
        // 0x1d0087e4
        __asm_ins(2, 4, 4);
    } else {
        // 0x1d0087c0
        __asm_ins(15, 4, 4);
    }
    // 0x1d0087f8
    __asm_ins(1, 15, 1);
    // 0x1d008818
    return pthread_cond_destroy3(&v1);
}

// Address range: 0x1d009b00 - 0x1d009df4
int32_t function_1d009b00(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    *(char *)a1 = 0;
    char * v2 = (char *)(v1 + 1); // 0x1d009b14
    *v2 = 0;
    char * v3 = (char *)(v1 + 2); // 0x1d009b18
    *v3 = 0;
    char * v4 = (char *)(v1 + 3); // 0x1d009b1c
    *v4 = 0;
    char * v5 = (char *)(v1 + 4); // 0x1d009b20
    *v5 = 0;
    char * v6 = (char *)(v1 + 5); // 0x1d009b24
    *v6 = 0;
    char * v7 = (char *)(v1 + 6); // 0x1d009b28
    *v7 = 0;
    char * v8 = (char *)(v1 + 7); // 0x1d009b2c
    *v8 = 0;
    uint16_t v9 = *(int16_t *)-0x5ffffe18; // 0x1d009b38
    *(char *)a1 = (char)v9;
    *v2 = (char)(v9 / 256);
    int32_t v10 = *(int32_t*)0xa00001e4; // 0x1d009b48
    uint32_t v11 = (int32_t)(0x51eb851f * (int64_t)v10 / 0x2000000000) - (v10 >> 31); // 0x1d009b64
    *v3 = (char)v11;
    *v4 = (char)__asm_ext(v11 % 0x10000, 8, 7);
    *v4 = (char)__asm_ins(__asm_ext(*(int32_t*)0xa0013534, 23, 1), 7, 1);
    int32_t v12 = 0; // 0x1d009b98
    int32_t v13; // 0x1d009b00
    if (*(int32_t*)0xa00134cc < 4) {
        goto lab_0x1d009c8c;
    } else {
        int32_t v14 = *(int32_t*)0xa00134ec; // 0x1d009ba4
        v13 = v14;
        if (v14 >= 4) {
            // 0x1d009d58
            v13 = v14;
            if (*(int32_t*)0xa0013408 >= 4) {
                // 0x1d009bbc
                v13 = v14;
                if (*(int32_t*)0xa00133a8 >= 4) {
                    // 0x1d009d70
                    *v5 = *(char*)0xa00133a3;
                    *v6 = *(char*)0xa00133a2;
                    *v7 = *(char*)0xa00134c0 ^ -128;
                    v12 = 0;
                    if (*(int32_t*)0xa00134cc >= 4) {
                        // 0x1d009d70
                        v13 = *(int32_t*)0xa00134ec;
                        goto lab_0x1d009bd0;
                    } else {
                        goto lab_0x1d009c8c;
                    }
                } else {
                    goto lab_0x1d009bd0;
                }
            } else {
                goto lab_0x1d009bd0;
            }
        } else {
            goto lab_0x1d009bd0;
        }
    }
  lab_0x1d009c8c:
    // 0x1d009c8c
    *v8 = (char)__asm_ins(v12, 0, 1);
    *v8 = (char)__asm_ins((int32_t)*(char*)0xa0000182, 1, 1);
    *v8 = (char)__asm_ins(function_1d021a3c(), 2, 1);
    *v8 = (char)__asm_ins((int32_t)(function_1d01f8a8() != 0), 3, 1);
    int32_t v15 = 1; // 0x1d009cd8
    if (*(int32_t*)0xa0013408 >= 4) {
        // 0x1d009cdc
        v15 = *(int32_t*)0xa00133a8 < 4;
    }
    // 0x1d009cec
    *v8 = (char)__asm_ins(v15, 4, 1);
    int32_t v16 = 1; // 0x1d009d0c
    if (*(int32_t*)0xa00134cc >= 4) {
        // 0x1d009d10
        v16 = *(int32_t*)0xa00134ec < 4;
    }
    // 0x1d009d20
    *v8 = (char)__asm_ins(v16, 5, 1);
    *v8 = (char)__asm_ins((int32_t)*(char*)0xa0000183, 6, 1);
    int32_t result = __asm_ins((int32_t)(*(int32_t*)0xa001353c == 0), 7, 1); // 0x1d009d4c
    *v8 = (char)result;
    return result;
  lab_0x1d009bd0:
    // 0x1d009bd0
    v12 = 0;
    if (v13 >= 4) {
        // 0x1d009db8
        v12 = 0;
        if (*(int32_t*)0xa0013408 >= 4) {
            // 0x1d009be8
            v12 = 0;
            if (*(int32_t*)0xa00133a8 >= 4) {
                // 0x1d009dd0
                v12 = 0;
                if (*(int32_t*)0xa001353c == 0) {
                    goto lab_0x1d009c8c;
                } else {
                    // 0x1d009c00
                    v12 = 0;
                    if ((*(int32_t*)0xa0013534 & 0x810000) == 0x10000) {
                        // 0x1d009c18
                        v12 = 0;
                        if (*(char*)0xa0000182 == 0) {
                            // 0x1d009c28
                            v12 = 0;
                            if (*(char*)0xa0000183 == 0) {
                                // 0x1d009c38
                                if (function_1d01f8a8() == 0) {
                                    goto lab_0x1d009c58;
                                } else {
                                    // 0x1d009c48
                                    v12 = 0;
                                    if (function_1d01f8d4() == 0) {
                                        goto lab_0x1d009c8c;
                                    } else {
                                        goto lab_0x1d009c58;
                                    }
                                }
                            } else {
                                goto lab_0x1d009c8c;
                            }
                        } else {
                            goto lab_0x1d009c8c;
                        }
                    } else {
                        goto lab_0x1d009c8c;
                    }
                }
            } else {
                goto lab_0x1d009c8c;
            }
        } else {
            goto lab_0x1d009c8c;
        }
    } else {
        goto lab_0x1d009c8c;
    }
  lab_0x1d009c58:
    // 0x1d009c58
    v12 = 0;
    if (function_1d021a3c() == 0) {
        // 0x1d009c68
        v12 = (*(int32_t*)0xa00134c0 & 0xc00000) == 0x800000;
    }
    goto lab_0x1d009c8c;
}

// Address range: 0x1d009df4 - 0x1d009f48
int32_t time(int32_t a1) {
    // 0x1d009df4
    int32_t v1; // bp-16, 0x1d009df4
    int32_t v2; // bp-24, 0x1d009df4
    if (*(char*)0xa0000181 == 0) {
        // 0x1d009e88
        if (a1 != 0) {
            // 0x1d009f40
            return -0x5fff0000;
        }
    } else {
        int32_t v3 = 0; // 0x1d009e14
        if (*(int32_t*)0xa0013404 != 0) {
            // 0x1d009e18
            v3 = __asm_ins(0, 23, 1);
        }
        // 0x1d009e3c
        v1 = v3;
        v2 = 936;
        if (a1 != 0) {
            // 0x1d009e50
            *(int32_t*)0xbf8860e8 = 32;
            // 0x1d009f40
            return function_1d01d59c(&v2);
        }
        // 0x1d009e6c
        pthread_cond_destroy(&v2);
        *(int32_t*)0xbf8860e4 = 32;
    }
    // 0x1d009e90
    if (function_1d019a50() == 0) {
        // 0x1d009f40
        return -0x60000000;
    }
    // 0x1d009ea0
    if (*(int32_t*)0xa0000178 == 0) {
        // 0x1d009eac
        if (*(int32_t*)0xa000017c == 0) {
            // 0x1d009ebc
            v2 = 101;
            function_1d009b00(&v1);
            function_1d01f688(&v1);
            pthread_cond_destroy2(&v2);
        }
    }
    // 0x1d009ee8
    if (*(int32_t*)0xa001350c != 0) {
        // 0x1d009ef4
        if (__asm_ext(*(int32_t*)0xa0013508, 24, 1) != 0) {
            // 0x1d009f40
            return function_1d008784();
        }
    }
    // 0x1d009f08
    if (*(int32_t*)0xa001352c != 0) {
        // 0x1d009f14
        if (__asm_ext(*(int32_t*)0xa0013528, 24, 1) != 0) {
            // 0x1d009f40
            return function_1d008784();
        }
    }
    // 0x1d009f28
    if (*(char*)0xa0000181 == 0) {
        // 0x1d009f40
        return 0;
    }
    // 0x1d009f40
    return function_1d008784();
}

// Address range: 0x1d015c50 - 0x1d015e78
int32_t exit(void) {
    // 0x1d015c50
    *(int32_t*)0xbf881074 = 0x2000000;
    *(int32_t*)0xbf885220 = 255;
    *(int32_t*)0xbf885200 = 255;
    *(int32_t*)0xbf885300 = 0;
    *(int32_t*)0xbf885310 = 0;
    *(int32_t*)0xbf885320 = 0;
    *(int32_t*)0xbf885330 = 0;
    *(int32_t*)0xbf8852e0 = 0;
    *(int32_t*)0xbf885230 = 159;
    *(int32_t*)0xbf885210 = 159;
    *(int32_t*)0xbf885070 = *(int32_t*)0xbf885070 % 16;
    *(char*)0xbf885080 = (char)__asm_ins(1, 0, 1);
    uint32_t v1 = __asm_ext(-0x5ffffc00, 0, 29); // 0x1d015cdc
    *(int32_t*)0xbf8852d0 = v1 / 0x1000000;
    *(int32_t*)0xbf8852c0 = v1 / 0x10000;
    *(int32_t*)0xbf885270 = v1 / 256;
    int32_t v2 = 0; // 0x1d015d14
    int32_t v3 = 0; // 0x1d015d14
    *(int32_t *)(v2 - 0x5ffffc00) = 0;
    *(int32_t *)(v2 - 0x5ffffbfc) = 0;
    v3++;
    v2 = 8 * v3;
    while (v3 != 16) {
        // 0x1d015d18
        *(int32_t *)(v2 - 0x5ffffc00) = 0;
        *(int32_t *)(v2 - 0x5ffffbfc) = 0;
        v3++;
        v2 = 8 * v3;
    }
    // 0x1d015d38
    *(char*)0xbf885250 = (char)__asm_ins(1, 1, 1);
    *(int32_t*)0xbf885260 = 0;
    *(char*)0xbf885250 = (char)__asm_ins(0, 5, 1);
    *(char*)0xbf885250 = (char)__asm_ins(0, 1, 1);
    if ((*(int32_t*)0xbf885200 & 8) != 0) {
        *(int32_t*)0xbf885200 = 8;
        *(char*)0xa0000484 = 0;
        *(char*)0xa00004d4 = 0;
        *(int32_t*)0xa00004d4 = __asm_ins(0, 8, 16);
        while ((*(int32_t*)0xbf885200 & 8) != 0) {
            // 0x1d015d90
            *(int32_t*)0xbf885200 = 8;
            *(char*)0xa0000484 = 0;
            *(char*)0xa00004d4 = 0;
            *(int32_t*)0xa00004d4 = __asm_ins(0, 8, 16);
        }
    }
    // 0x1d015dc0
    int32_t v4; // 0x1d015c50
    *(int32_t *)(v4 - 0x7f08) = 1;
    *(int32_t *)(v4 - 0x7f00) = 1;
    *(int32_t *)(v4 - 0x7ed0) = 0;
    *(int32_t *)(v4 - 0x7ecc) = 0;
    *(int32_t *)(v4 - 0x7eec) = 0;
    int32_t v5 = -0x5ffffe00; // 0x1d015df4
    int32_t v6 = -0x5ffffdf0; // 0x1d015df4
    int32_t v7 = 0; // 0x1d015df4
    *(int32_t *)v6 = 0;
    *(int32_t *)v5 = 0;
    int32_t v8 = v7 + v4;
    *(char *)(v8 - 0x7eb8) = 0;
    *(char *)(v8 - 0x7ee8) = 0;
    v7++;
    v5 += 4;
    v6 += 4;
    while (v7 != 4) {
        // 0x1d015df8
        *(int32_t *)v6 = 0;
        *(int32_t *)v5 = 0;
        v8 = v7 + v4;
        *(char *)(v8 - 0x7eb8) = 0;
        *(char *)(v8 - 0x7ee8) = 0;
        v7++;
        v5 += 4;
        v6 += 4;
    }
    // 0x1d015e20
    *(int32_t*)0xa0000210 = -0x5ffffbf0;
    *(int32_t*)0xbf885300 = 13;
    *(int32_t*)0xa0000404 = __asm_ext(v4 - 0x7ef4, 0, 29);
    *(int16_t *)-0x5ffffbfe = (int16_t)__asm_ins(64, 0, 10);
    *(int16_t *)-0x5ffffc00 = 132;
    *(char *)(v4 - 0x7f04) = 0;
    *(int32_t *)(v4 - 0x7ec8) = 0;
    return 132;
}

// Address range: 0x1d0179b4 - 0x1d0179c4
int32_t function_1d0179b4(int32_t a1) {
    // 0x1d0179b4
    int32_t v1; // 0x1d0179b4
    return (int32_t)*(char *)(a1 - 0x7f20 + v1);
}

// Address range: 0x1d017efc - 0x1d018130
int32_t function_1d017efc(int32_t a1) {
    switch (a1) {
        case 3: {
            // 0x1d017f34
            *(int32_t*)0xbf8860e4 = 512;
            *(int32_t*)0xbf8860c4 = 512;
            *(int32_t*)0xbf805820 = 160;
            while ((*(int32_t*)0xbf805810 & 0x1f000000) == 0) {
                // continue -> 0x1d017fc8
            }
            // 0x1d01805c
            *(int32_t*)0xbf805820 = 0;
            while ((*(int32_t*)0xbf805810 & 0x1f000000) == 0) {
                // continue -> 0x1d018068
            }
            // 0x1d018078
            *(int32_t*)0xbf8860e8 = 512;
            *(int32_t*)0xbf8860c4 = 512;
            return 0;
        }
        case 4: {
            // 0x1d017f50
            *(int32_t*)0xbf886064 = 256;
            *(int32_t*)0xbf886044 = 256;
            *(int32_t*)0xbf805c20 = 160;
            while ((*(int32_t*)0xbf805c10 & 0x1f000000) == 0) {
                // continue -> 0x1d017ff8
            }
            // 0x1d018088
            *(int32_t*)0xbf805c20 = 0;
            while ((*(int32_t*)0xbf805c10 & 0x1f000000) == 0) {
                // continue -> 0x1d018094
            }
            // 0x1d0180a4
            *(int32_t*)0xbf886068 = 256;
            *(int32_t*)0xbf886044 = 256;
            return 0;
        }
        case 2: {
            // 0x1d017f18
            *(int32_t*)0xbf8861a4 = 512;
            *(int32_t*)0xbf886184 = 512;
            *(int32_t*)0xbf805a20 = 160;
            while ((*(int32_t*)0xbf805a10 & 0x1f000000) == 0) {
                // continue -> 0x1d017f98
            }
            // 0x1d018030
            *(int32_t*)0xbf805a20 = 0;
            while ((*(int32_t*)0xbf805a10 & 0x1f000000) == 0) {
                // continue -> 0x1d01803c
            }
            // 0x1d01804c
            *(int32_t*)0xbf8861a8 = 512;
            *(int32_t*)0xbf886184 = 512;
            return 0;
        }
    }
    // 0x1d018128
    return 0;
}

// Address range: 0x1d018514 - 0x1d0186cc
int32_t function_1d018514(int32_t a1, uint32_t a2) {
    switch (a1) {
        case 3: {
            // 0x1d018564
            *(int32_t*)0xbf8860e4 = 512;
            *(int32_t*)0xbf8860c4 = 512;
            *(int32_t*)0xbf805820 = (1 << a2 % 4) % 128 | 128;
            while ((*(int32_t*)0xbf805810 & 0x1f000000) == 0) {
                // continue -> 0x1d01861c
            }
            // 0x1d018698
            *(int32_t*)0xbf8860e8 = 512;
            *(int32_t*)0xbf8860c4 = 512;
            return 512;
        }
        case 4: {
            // 0x1d01858c
            *(int32_t*)0xbf886064 = 256;
            *(int32_t*)0xbf886044 = 256;
            *(int32_t*)0xbf805c20 = (1 << a2 % 4) % 128 | 128;
            while ((*(int32_t*)0xbf805c10 & 0x1f000000) == 0) {
                // continue -> 0x1d018648
            }
            // 0x1d0186b4
            *(int32_t*)0xbf886068 = 256;
            *(int32_t*)0xbf886044 = 256;
            return 256;
        }
        case 2: {
            // 0x1d018538
            *(int32_t*)0xbf8861a4 = 512;
            *(int32_t*)0xbf886184 = 512;
            *(int32_t*)0xbf805a20 = (1 << a2 % 4) % 128 | 128;
            while ((*(int32_t*)0xbf805a10 & 0x1f000000) == 0) {
                // continue -> 0x1d0185f0
            }
            // 0x1d01867c
            *(int32_t*)0xbf8861a8 = 512;
            *(int32_t*)0xbf886184 = 512;
            // 0x1d01868c
            return 512;
        }
    }
    // 0x1d01868c
    return 512;
}

// Address range: 0x1d0188a4 - 0x1d018b80
int32_t function_1d0188a4(int32_t a1, int32_t a2, uint32_t a3, int32_t a4, int32_t a5, uint32_t a6) {
    switch (a1) {
        case 3: {
            // 0x1d0188fc
            *(int32_t*)0xbf8860e4 = 512;
            *(int32_t*)0xbf8860c4 = 512;
            // break -> 0x1d018930
            break;
        }
        case 4: {
            // 0x1d018918
            *(int32_t*)0xbf886064 = 256;
            *(int32_t*)0xbf886044 = 256;
            // break -> 0x1d018930
            break;
        }
        case 2: {
            // 0x1d0188e0
            *(int32_t*)0xbf8861a4 = 512;
            *(int32_t*)0xbf886184 = 512;
            // break -> 0x1d018930
            break;
        }
    }
    char v1; // bp-7, 0x1d0188a4
    if (a4 == 0) {
        // 0x1d018970
        v1 = a3 / 8;
    } else {
        // 0x1d018940
        v1 = a3 / 0x200000;
        __asm_ins(0, 0, 5);
        __asm_ext(a3, 16, 2);
    }
    int32_t * v2 = (int32_t*)0xbf805a20; // 0x1d0188a4
    int32_t * v3 = (int32_t*)0xbf805a10; // 0x1d0188a4
    int32_t result = 2; // 0x1d0188a4
    switch (a1) {
        case 3: {
            // 0x1d0189d0
            v2 = (int32_t*)0xbf805820;
            v3 = (int32_t*)0xbf805810;
            goto lab_0x1d0189e0;
        }
        case 4: {
            // 0x1d0189bc
            v2 = (int32_t*)0xbf805c20;
            v3 = (int32_t*)0xbf805c10;
            goto lab_0x1d0189e0;
        }
        case 2: {
            goto lab_0x1d0189e0;
        }
        default: {
            return result;
        }
    }
  lab_0x1d0189e0:;
    uint32_t v4 = a6 % 256; // 0x1d0188a8
    int32_t v5 = v4 < 8 ? v4 : 8;
    int32_t v6 = &v1;
    *v2 = (int32_t)*(char *)(v6 - 1);
    int32_t v7 = v6 + 1; // 0x1d0189f4
    int32_t v8; // bp-2, 0x1d0188a4
    while (v6 != (int32_t)&v8) {
        // 0x1d0189ec
        v6 = v7;
        *v2 = (int32_t)*(char *)(v6 - 1);
        v7 = v6 + 1;
    }
    // 0x1d018a04
    while ((*v3 & 0x1e000000) < 0x6000000) {
        // continue -> 0x1d018a04
    }
    int32_t * v9 = (int32_t*)0xbf805a20; // 0x1d0188a4
    int32_t * v10 = (int32_t*)0xbf805a10; // 0x1d0188a4
    result = 2;
    switch (a1) {
        case 3: {
            // 0x1d018a78
            v9 = (int32_t*)0xbf805820;
            v10 = (int32_t*)0xbf805810;
            goto lab_0x1d018a88;
        }
        case 4: {
            // 0x1d018a64
            v9 = (int32_t*)0xbf805c20;
            v10 = (int32_t*)0xbf805c10;
            goto lab_0x1d018a88;
        }
        case 2: {
            goto lab_0x1d018a88;
        }
        default: {
            return result;
        }
    }
  lab_0x1d018a88:
    // 0x1d018a88
    if (a5 == 0) {
        if (v5 != 0) {
            // 0x1d018ac4
            *v9 = 0;
        }
    } else {
        // 0x1d018aa0
        if (v5 != 0) {
            int32_t v11 = a5 + 1;
            *v9 = (int32_t)*(char *)a5;
            int32_t v12 = v11; // 0x1d018ab8
            while (v11 != v5 + a5) {
                // 0x1d018aac
                v11 = v12 + 1;
                *v9 = (int32_t)*(char *)v12;
                v12 = v11;
            }
        }
    }
    // 0x1d018ad8
    while ((*v10 & 0x1f000000) < 0x1000000 * v5) {
        // continue -> 0x1d018adc
    }
    // 0x1d018b10
    result = 2;
    switch (a1) {
        case 3: {
            // 0x1d018b44
            *(int32_t*)0xbf8860e8 = 512;
            *(int32_t*)0xbf8860c4 = 512;
            result = 512;
            // break -> 0x1d018b78
            break;
        }
        case 4: {
            // 0x1d018b60
            *(int32_t*)0xbf886068 = 256;
            *(int32_t*)0xbf886044 = 256;
            result = 256;
            // break -> 0x1d018b78
            break;
        }
        case 2: {
            // 0x1d018b28
            *(int32_t*)0xbf8861a8 = 512;
            *(int32_t*)0xbf886184 = 512;
            result = 512;
            // break -> 0x1d018b78
            break;
        }
    }
    // 0x1d018b78
    return result;
}

// Address range: 0x1d019a50 - 0x1d019a5c
int32_t function_1d019a50(void) {
    // 0x1d019a50
    return (int32_t)*(char*)0xa0013ad4;
}

// Address range: 0x1d01b4a0 - 0x1d01b4b4
int32_t function_1d01b4a0(void) {
    // 0x1d01b4a0
    return (int32_t)*(char*)0xa00137cc;
}

// Address range: 0x1d01bd1c - 0x1d01bfac
int32_t pthread_cond_destroy2(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    int32_t v2; // 0x1d01bd1c
    if ((*(int32_t *)(v2 - 0x7f18) & 32) != 0) {
        int32_t v3 = *(int32_t*)0xa0000eb8; // 0x1d01bd44
        uint32_t v4 = *(int32_t*)0xa0000eb4; // 0x1d01bd4c
        uint32_t v5 = v4 % 0x1000; // 0x1d01bd50
        if (v5 != (v3 + 1) % 0x1000) {
            int32_t * v6 = (int32_t *)(v1 + 4); // 0x1d01bd74
            uint32_t v7 = *v6; // 0x1d01bd74
            int32_t v8 = __asm_ext(v7, 28, 1); // 0x1d01bd78
            int32_t v9; // 0x1d01bd1c
            if (v8 == 0) {
                // 0x1d01bda0
                v9 = v4 % 2048;
            } else {
                // 0x1d01bd84
                v9 = __asm_ext(*v6, 10, 18) | 0x40000 * v5 & 0x1ffc0000;
            }
            int32_t v10 = 16 * v3 & 0xfff0; // 0x1d01bd60
            uint32_t v11 = v7 % 16; // 0x1d01bd80
            __asm_ins(v9, 0, 29);
            __asm_ins(v8, 29, 1);
            __asm_ins(v11, 30, 2);
            *(int32_t *)(v10 - 0x5ffff140) = __asm_ins(v11 / 4, 30, 2);
            __asm_ins(5, 27, 3);
            *(int32_t *)(v10 - 0x5ffff144) = __asm_ins(*(int32_t *)(v2 - 0x7f14), 0, 27);
            __asm_lwl(*(int32_t *)(v1 + 11));
            int32_t v12 = __asm_lwr(*(int32_t *)(v1 + 8)); // 0x1d01bde4
            __asm_lwl(*(int32_t *)(v1 + 15));
            int32_t v13 = __asm_lwr(*(int32_t *)(v1 + 12)); // 0x1d01bdec
            *(int32_t *)(v10 - 0x5ffff13c) = v12;
            *(int32_t *)(v10 - 0x5ffff138) = v13;
            uint32_t v14 = (*(int32_t*)0xa0000eb8 + 1) % 0x1000; // 0x1d01be08
            if (*(int32_t*)0xa0000eb4 % 0x1000 != v14) {
                // 0x1d01be1c
                *(int32_t*)0xa0000eb8 = v14;
            }
        }
    }
    int32_t v15 = *(int32_t*)0xa0000aa8 % 64; // 0x1d01bec0
    int32_t result2; // 0x1d01bd1c
    if (v15 == *(int32_t*)0xa0000aac % 64) {
      lab_0x1d01bf88:;
        int32_t result = function_1d01d840(a1); // 0x1d01bf8c
        if (result != 0) {
            // 0x1d01bf98
            return result;
        }
        int32_t v16 = *(int32_t*)0xa0000aac; // 0x1d01bf1c
        uint32_t v17 = (v16 + 1) % 64; // 0x1d01bf28
        if (*(int32_t*)0xa0000aa8 % 64 == v17) {
            // 0x1d01bf74
            *(int32_t*)0xa0000ab0 = *(int32_t*)0xa0000ab0 + 1;
            result2 = 0;
        } else {
            int32_t v18 = 16 * v16 & 1008; // 0x1d01bf3c
            *(int32_t *)(v18 - 0x5ffff54c) = v17;
            *(int32_t *)(v18 - 0x5ffff548) = *(int32_t *)(v1 + 4);
            *(int32_t *)(v18 - 0x5ffff544) = *(int32_t *)(v1 + 8);
            *(int32_t *)(v18 - 0x5ffff540) = *(int32_t *)(v1 + 12);
            *(int32_t*)0xa0000aac = v17;
            result2 = 1;
        }
        // 0x1d01bf98
        return result2;
    }
    int32_t v19 = *(int32_t *)(16 * v15 - 0x5ffff54c); // bp-32, 0x1d01bef0
    while (function_1d01d840(&v19) != 0) {
        int32_t v20 = *(int32_t*)0xa0000aa8; // 0x1d01bf0c
        int32_t v21 = *(int32_t*)0xa0000aac; // 0x1d01be30
        int32_t v22 = v21; // 0x1d01be3c
        int32_t v23 = v20; // 0x1d01be3c
        if ((v21 ^ v20) % 64 != 0) {
            // 0x1d01be40
            v23 = (v20 + 1) % 64;
            *(int32_t*)0xa0000aa8 = v23;
            v22 = *(int32_t*)0xa0000aac;
        }
        int32_t v24 = v23 % 64; // 0x1d01bec0
        if (v24 == v22 % 64) {
            goto lab_0x1d01bf88;
        }
        v19 = *(int32_t *)(16 * v24 - 0x5ffff54c);
    }
    int32_t v25 = *(int32_t*)0xa0000aac; // 0x1d01be50
    uint32_t v26 = (v25 + 1) % 64; // 0x1d01be5c
    if (*(int32_t*)0xa0000aa8 % 64 == v26) {
        // 0x1d01bea8
        *(int32_t*)0xa0000ab0 = *(int32_t*)0xa0000ab0 + 1;
        result2 = 0;
    } else {
        int32_t v27 = 16 * v25 & 1008; // 0x1d01be70
        *(int32_t *)(v27 - 0x5ffff54c) = v26;
        *(int32_t *)(v27 - 0x5ffff548) = *(int32_t *)(v1 + 4);
        *(int32_t *)(v27 - 0x5ffff544) = *(int32_t *)(v1 + 8);
        *(int32_t *)(v27 - 0x5ffff540) = *(int32_t *)(v1 + 12);
        *(int32_t*)0xa0000aac = v26;
        result2 = 1;
    }
    // 0x1d01bf98
    return result2;
}

// Address range: 0x1d01bfac - 0x1d01c23c
int32_t pthread_cond_destroy3(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    int32_t v2; // 0x1d01bfac
    if ((*(int32_t *)(v2 - 0x7f18) & 128) != 0) {
        int32_t v3 = *(int32_t*)0xa0000eb8; // 0x1d01bfd4
        uint32_t v4 = *(int32_t*)0xa0000eb4; // 0x1d01bfdc
        uint32_t v5 = v4 % 0x1000; // 0x1d01bfe0
        if (v5 != (v3 + 1) % 0x1000) {
            int32_t * v6 = (int32_t *)(v1 + 4); // 0x1d01c004
            uint32_t v7 = *v6; // 0x1d01c004
            int32_t v8 = __asm_ext(v7, 28, 1); // 0x1d01c008
            int32_t v9; // 0x1d01bfac
            if (v8 == 0) {
                // 0x1d01c030
                v9 = v4 % 2048;
            } else {
                // 0x1d01c014
                v9 = __asm_ext(*v6, 10, 18) | 0x40000 * v5 & 0x1ffc0000;
            }
            int32_t v10 = 16 * v3 & 0xfff0; // 0x1d01bff0
            uint32_t v11 = v7 % 16; // 0x1d01c010
            __asm_ins(v9, 0, 29);
            __asm_ins(v8, 29, 1);
            __asm_ins(v11, 30, 2);
            *(int32_t *)(v10 - 0x5ffff140) = __asm_ins(v11 / 4, 30, 2);
            __asm_ins(7, 27, 3);
            *(int32_t *)(v10 - 0x5ffff144) = __asm_ins(*(int32_t *)(v2 - 0x7f14), 0, 27);
            __asm_lwl(*(int32_t *)(v1 + 11));
            int32_t v12 = __asm_lwr(*(int32_t *)(v1 + 8)); // 0x1d01c074
            __asm_lwl(*(int32_t *)(v1 + 15));
            int32_t v13 = __asm_lwr(*(int32_t *)(v1 + 12)); // 0x1d01c07c
            *(int32_t *)(v10 - 0x5ffff13c) = v12;
            *(int32_t *)(v10 - 0x5ffff138) = v13;
            uint32_t v14 = (*(int32_t*)0xa0000eb8 + 1) % 0x1000; // 0x1d01c098
            if (*(int32_t*)0xa0000eb4 % 0x1000 != v14) {
                // 0x1d01c0ac
                *(int32_t*)0xa0000eb8 = v14;
            }
        }
    }
    int32_t v15 = *(int32_t*)0xa000069c % 64; // 0x1d01c150
    int32_t result2; // 0x1d01bfac
    if (v15 == *(int32_t*)0xa00006a0 % 64) {
      lab_0x1d01c218:;
        int32_t result = function_1d01db50(a1); // 0x1d01c21c
        if (result != 0) {
            // 0x1d01c228
            return result;
        }
        int32_t v16 = *(int32_t*)0xa00006a0; // 0x1d01c1ac
        uint32_t v17 = (v16 + 1) % 64; // 0x1d01c1b8
        if (*(int32_t*)0xa000069c % 64 == v17) {
            // 0x1d01c204
            *(int32_t*)0xa00006a4 = *(int32_t*)0xa00006a4 + 1;
            result2 = 0;
        } else {
            int32_t v18 = 16 * v16 & 1008; // 0x1d01c1cc
            *(int32_t *)(v18 - 0x5ffff958) = v17;
            *(int32_t *)(v18 - 0x5ffff954) = *(int32_t *)(v1 + 4);
            *(int32_t *)(v18 - 0x5ffff950) = *(int32_t *)(v1 + 8);
            *(int32_t *)(v18 - 0x5ffff94c) = *(int32_t *)(v1 + 12);
            *(int32_t*)0xa00006a0 = v17;
            result2 = 1;
        }
        // 0x1d01c228
        return result2;
    }
    int32_t v19 = *(int32_t *)(16 * v15 - 0x5ffff958); // bp-32, 0x1d01c180
    while (function_1d01db50(&v19) != 0) {
        int32_t v20 = *(int32_t*)0xa000069c; // 0x1d01c19c
        int32_t v21 = *(int32_t*)0xa00006a0; // 0x1d01c0c0
        int32_t v22 = v21; // 0x1d01c0cc
        int32_t v23 = v20; // 0x1d01c0cc
        if ((v21 ^ v20) % 64 != 0) {
            // 0x1d01c0d0
            v23 = (v20 + 1) % 64;
            *(int32_t*)0xa000069c = v23;
            v22 = *(int32_t*)0xa00006a0;
        }
        int32_t v24 = v23 % 64; // 0x1d01c150
        if (v24 == v22 % 64) {
            goto lab_0x1d01c218;
        }
        v19 = *(int32_t *)(16 * v24 - 0x5ffff958);
    }
    int32_t v25 = *(int32_t*)0xa00006a0; // 0x1d01c0e0
    uint32_t v26 = (v25 + 1) % 64; // 0x1d01c0ec
    if (*(int32_t*)0xa000069c % 64 == v26) {
        // 0x1d01c138
        *(int32_t*)0xa00006a4 = *(int32_t*)0xa00006a4 + 1;
        result2 = 0;
    } else {
        int32_t v27 = 16 * v25 & 1008; // 0x1d01c100
        *(int32_t *)(v27 - 0x5ffff958) = v26;
        *(int32_t *)(v27 - 0x5ffff954) = *(int32_t *)(v1 + 4);
        *(int32_t *)(v27 - 0x5ffff950) = *(int32_t *)(v1 + 8);
        *(int32_t *)(v27 - 0x5ffff94c) = *(int32_t *)(v1 + 12);
        *(int32_t*)0xa00006a0 = v26;
        result2 = 1;
    }
    // 0x1d01c228
    return result2;
}

// Address range: 0x1d01c23c - 0x1d01c348
int32_t pthread_cond_destroy4(uint32_t a1) {
    // 0x1d01c23c
    int32_t v1; // 0x1d01c23c
    if ((*(int32_t *)(v1 - 0x7f18) & 2) == 0) {
        // 0x1d01c334
        return function_1d01d03c(a1);
    }
    int32_t v2 = *(int32_t*)0xa0000eb8; // 0x1d01c258
    if ((*(int32_t*)0xa0000eb4 ^ v2 + 1) % 0x1000 == 0) {
        // 0x1d01c334
        return function_1d01d03c(a1);
    }
    int32_t * v3 = (int32_t *)(a1 + 4); // 0x1d01c288
    uint32_t v4 = *v3; // 0x1d01c288
    int32_t v5 = __asm_ext(v4, 28, 1); // 0x1d01c28c
    int32_t v6; // 0x1d01c23c
    if (v5 == 0) {
        // 0x1d01c2b4
        v6 = a1 % 2048;
    } else {
        // 0x1d01c298
        v6 = __asm_ext(*v3, 10, 18) | 0x40000 * a1 & 0x1ffc0000;
    }
    int32_t v7 = 16 * v2 & 0xfff0; // 0x1d01c274
    uint32_t v8 = v4 % 16; // 0x1d01c294
    __asm_ins(v6, 0, 29);
    __asm_ins(v5, 29, 1);
    __asm_ins(v8, 30, 2);
    *(int32_t *)(v7 - 0x5ffff140) = __asm_ins(v8 / 4, 30, 2);
    __asm_ins(1, 27, 3);
    *(int32_t *)(v7 - 0x5ffff144) = __asm_ins(*(int32_t *)(v1 - 0x7f14), 0, 27);
    __asm_lwl(*(int32_t *)(a1 + 11));
    int32_t v9 = __asm_lwr(*(int32_t *)(a1 + 8)); // 0x1d01c2f8
    __asm_lwl(*(int32_t *)(a1 + 15));
    int32_t v10 = __asm_lwr(*(int32_t *)(a1 + 12)); // 0x1d01c300
    *(int32_t *)(v7 - 0x5ffff13c) = v9;
    *(int32_t *)(v7 - 0x5ffff138) = v10;
    uint32_t v11 = (*(int32_t*)0xa0000eb8 + 1) % 0x1000; // 0x1d01c31c
    if (*(int32_t*)0xa0000eb4 % 0x1000 != v11) {
        // 0x1d01c330
        *(int32_t*)0xa0000eb8 = v11;
    }
    // 0x1d01c334
    return function_1d01d03c(a1);
}

// Address range: 0x1d01c348 - 0x1d01c454
int32_t pthread_cond_destroy(int32_t * a1) {
    uint32_t v1 = (int32_t)a1;
    int32_t v2; // 0x1d01c348
    if ((*(int32_t *)(v2 - 0x7f18) & 8) == 0) {
        // 0x1d01c440
        return function_1d01d50c(v1);
    }
    int32_t v3 = *(int32_t*)0xa0000eb8; // 0x1d01c364
    if ((*(int32_t*)0xa0000eb4 ^ v3 + 1) % 0x1000 == 0) {
        // 0x1d01c440
        return function_1d01d50c(v1);
    }
    int32_t * v4 = (int32_t *)(v1 + 4); // 0x1d01c394
    uint32_t v5 = *v4; // 0x1d01c394
    int32_t v6 = __asm_ext(v5, 28, 1); // 0x1d01c398
    int32_t v7; // 0x1d01c348
    if (v6 == 0) {
        // 0x1d01c3c0
        v7 = v1 % 2048;
    } else {
        // 0x1d01c3a4
        v7 = __asm_ext(*v4, 10, 18) | 0x40000 * v1 & 0x1ffc0000;
    }
    int32_t v8 = 16 * v3 & 0xfff0; // 0x1d01c380
    uint32_t v9 = v5 % 16; // 0x1d01c3a0
    __asm_ins(v7, 0, 29);
    __asm_ins(v6, 29, 1);
    __asm_ins(v9, 30, 2);
    *(int32_t *)(v8 - 0x5ffff140) = __asm_ins(v9 / 4, 30, 2);
    __asm_ins(3, 27, 3);
    *(int32_t *)(v8 - 0x5ffff144) = __asm_ins(*(int32_t *)(v2 - 0x7f14), 0, 27);
    __asm_lwl(*(int32_t *)(v1 + 11));
    int32_t v10 = __asm_lwr(*(int32_t *)(v1 + 8)); // 0x1d01c404
    __asm_lwl(*(int32_t *)(v1 + 15));
    int32_t v11 = __asm_lwr(*(int32_t *)(v1 + 12)); // 0x1d01c40c
    *(int32_t *)(v8 - 0x5ffff13c) = v10;
    *(int32_t *)(v8 - 0x5ffff138) = v11;
    uint32_t v12 = (*(int32_t*)0xa0000eb8 + 1) % 0x1000; // 0x1d01c428
    if (*(int32_t*)0xa0000eb4 % 0x1000 != v12) {
        // 0x1d01c43c
        *(int32_t*)0xa0000eb8 = v12;
    }
    // 0x1d01c440
    return function_1d01d50c(v1);
}

// Address range: 0x1d01d03c - 0x1d01d0cc
int32_t function_1d01d03c(int32_t a1) {
    int32_t v1 = function_1d0252fc(0, 1); // 0x1d01d054
    int32_t result = 0; // 0x1d01d058
    if (v1 != 0) {
        // 0x1d01d060
        __asm_lwl(*(int32_t *)(a1 + 3));
        int32_t v2 = __asm_lwr(0); // 0x1d01d064
        __asm_lwl(*(int32_t *)(a1 + 7));
        int32_t v3 = __asm_lwr(*(int32_t *)(a1 + 4)); // 0x1d01d06c
        __asm_lwl(*(int32_t *)(a1 + 11));
        int32_t v4 = __asm_lwr(*(int32_t *)(a1 + 8)); // 0x1d01d074
        __asm_lwl(*(int32_t *)(a1 + 15));
        int32_t v5 = __asm_lwr(*(int32_t *)(a1 + 12)); // 0x1d01d07c
        __asm_swl(v2, *(int32_t *)(v1 + 3));
        __asm_swr(v2, *(int32_t *)v1);
        __asm_swl(v3, *(int32_t *)(v1 + 7));
        __asm_swr(v3, *(int32_t *)(v1 + 4));
        __asm_swl(v4, *(int32_t *)(v1 + 11));
        __asm_swr(v4, *(int32_t *)(v1 + 8));
        __asm_swl(v5, *(int32_t *)(v1 + 15));
        __asm_swr(v5, *(int32_t *)(v1 + 12));
        function_1d0263fc(0, 1);
        function_1d0252b0(0, 1);
        result = 1;
    }
    // 0x1d01d0bc
    return result;
}

// Address range: 0x1d01d50c - 0x1d01d59c
int32_t function_1d01d50c(int32_t a1) {
    int32_t v1 = function_1d0252fc(1, 1); // 0x1d01d524
    int32_t result = 0; // 0x1d01d528
    if (v1 != 0) {
        // 0x1d01d530
        __asm_lwl(*(int32_t *)(a1 + 3));
        int32_t v2 = __asm_lwr(1); // 0x1d01d534
        __asm_lwl(*(int32_t *)(a1 + 7));
        int32_t v3 = __asm_lwr(*(int32_t *)(a1 + 4)); // 0x1d01d53c
        __asm_lwl(*(int32_t *)(a1 + 11));
        int32_t v4 = __asm_lwr(*(int32_t *)(a1 + 8)); // 0x1d01d544
        __asm_lwl(*(int32_t *)(a1 + 15));
        int32_t v5 = __asm_lwr(*(int32_t *)(a1 + 12)); // 0x1d01d54c
        __asm_swl(v2, *(int32_t *)(v1 + 3));
        __asm_swr(v2, *(int32_t *)v1);
        __asm_swl(v3, *(int32_t *)(v1 + 7));
        __asm_swr(v3, *(int32_t *)(v1 + 4));
        __asm_swl(v4, *(int32_t *)(v1 + 11));
        __asm_swr(v4, *(int32_t *)(v1 + 8));
        __asm_swl(v5, *(int32_t *)(v1 + 15));
        __asm_swr(v5, *(int32_t *)(v1 + 12));
        function_1d0263fc(1, 1);
        function_1d0252b0(1, 1);
        result = 1;
    }
    // 0x1d01d58c
    return result;
}

// Address range: 0x1d01d59c - 0x1d01d62c
int32_t function_1d01d59c(int32_t * a1) {
    int32_t v1 = function_1d0252fc(1, 2); // 0x1d01d5b4
    int32_t result = 0; // 0x1d01d5b8
    if (v1 != 0) {
        int32_t v2 = (int32_t)a1;
        __asm_lwl(*(int32_t *)(v2 + 3));
        int32_t v3 = __asm_lwr(1); // 0x1d01d5c4
        __asm_lwl(*(int32_t *)(v2 + 7));
        int32_t v4 = __asm_lwr(*(int32_t *)(v2 + 4)); // 0x1d01d5cc
        __asm_lwl(*(int32_t *)(v2 + 11));
        int32_t v5 = __asm_lwr(*(int32_t *)(v2 + 8)); // 0x1d01d5d4
        __asm_lwl(*(int32_t *)(v2 + 15));
        int32_t v6 = __asm_lwr(*(int32_t *)(v2 + 12)); // 0x1d01d5dc
        __asm_swl(v3, *(int32_t *)(v1 + 3));
        __asm_swr(v3, *(int32_t *)v1);
        __asm_swl(v4, *(int32_t *)(v1 + 7));
        __asm_swr(v4, *(int32_t *)(v1 + 4));
        __asm_swl(v5, *(int32_t *)(v1 + 11));
        __asm_swr(v5, *(int32_t *)(v1 + 8));
        __asm_swl(v6, *(int32_t *)(v1 + 15));
        __asm_swr(v6, *(int32_t *)(v1 + 12));
        function_1d0263fc(1, 2);
        function_1d0252b0(1, 2);
        result = 1;
    }
    // 0x1d01d61c
    return result;
}

// Address range: 0x1d01d840 - 0x1d01d8f4
int32_t function_1d01d840(int32_t * a1) {
    int32_t result = function_1d0179b4(3); // 0x1d01d858
    if (result == 0 || (function_1d017efc(3) & 4) != 0) {
        // 0x1d01d8e0
        return 0;
    }
    int32_t v1 = (int32_t)a1;
    int32_t * v2 = (int32_t *)(v1 + 4); // 0x1d01d87c
    uint32_t v3 = *v2; // 0x1d01d87c
    int32_t v4 = __asm_ext(v3, 28, 1); // 0x1d01d880
    int32_t v5 = 3; // 0x1d01d888
    if (v4 != 0) {
        // 0x1d01d88c
        v5 = __asm_ext(*v2, 10, 18) | 0xc0000;
    }
    // 0x1d01d8b0
    function_1d0188a4(3, 0, v5, v4, v1 + 8, v3 % 16);
    function_1d018514(3, 0);
    // 0x1d01d8e0
    return result;
}

// Address range: 0x1d01db50 - 0x1d01dc04
int32_t function_1d01db50(int32_t * a1) {
    int32_t result = function_1d0179b4(2); // 0x1d01db68
    if (result == 0 || (function_1d017efc(2) & 4) != 0) {
        // 0x1d01dbf0
        return 0;
    }
    int32_t v1 = (int32_t)a1;
    int32_t * v2 = (int32_t *)(v1 + 4); // 0x1d01db8c
    uint32_t v3 = *v2; // 0x1d01db8c
    int32_t v4 = __asm_ext(v3, 28, 1); // 0x1d01db90
    int32_t v5 = 2; // 0x1d01db98
    if (v4 != 0) {
        // 0x1d01db9c
        v5 = __asm_ext(*v2, 10, 18) | 0x80000;
    }
    // 0x1d01dbc0
    function_1d0188a4(2, 0, v5, v4, v1 + 8, v3 % 16);
    function_1d018514(2, 0);
    // 0x1d01dbf0
    return result;
}

// Address range: 0x1d01f688 - 0x1d01f850
int32_t function_1d01f688(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = (int32_t)*(char *)(v1 + 7);
    int32_t v3; // 0x1d01f688
    char * v4 = (char *)(v3 - 0x7f8c);
    int32_t v5 = 0; // 0x1d01f6b4
    if ((v2 & 2) != 0) {
        // 0x1d01f6b8
        v5 = (int32_t)(*v4 % 2 ^ 1);
    }
    int32_t v6 = __asm_ext(v2, 1, 1); // 0x1d01f6c8
    char v7 = v6; // 0x1d01f6d0
    *v4 = v7;
    unsigned char v8 = *(char *)(v1 + 5); // 0x1d01f6d8
    int32_t v9 = 256 * (int32_t)v8 | (int32_t)*(char *)(v1 + 4); // 0x1d01f6e0
    *(int32_t *)(v3 - 0x7f84) = v9;
    *(int32_t *)(v3 - 0x7f80) = 200;
    int32_t v10 = __asm_ext(v2, 0, 1); // 0x1d01f6f0
    uint32_t v11 = __asm_ext(v2, 3, 1); // 0x1d01f6f8
    if (*(int32_t*)0xa0013b7c == 0) {
        goto lab_0x1d01f7f0;
    } else {
        if (v11 % 256 == 0) {
            goto lab_0x1d01f754;
        } else {
            // 0x1d01f71c
            if (*(char*)0xa0013b83 == 0) {
                // 0x1d01f72c
                *(char*)0xa0013b71 = 1;
                int32_t * v12 = (int32_t *)(v3 - 0x7f90); // 0x1d01f738
                if (*v12 == 0) {
                    // 0x1d01f744
                    *v12 = 1;
                    *(int32_t *)(v3 - 0x7f98) = 3;
                }
                goto lab_0x1d01f7f0;
            } else {
                goto lab_0x1d01f754;
            }
        }
    }
  lab_0x1d01f7f0:
    if (v5 != 0) {
        int32_t * v13 = (int32_t *)(v3 - 0x7f90); // 0x1d01f7f8
        if (*v13 == 1) {
            // 0x1d01f804
            *v13 = 2;
        }
    }
    // 0x1d01f810
    *(int32_t*)0xa0013b7c = 100;
    *(char*)0xa0013b80 = (char)v10;
    *(char*)0xa0013b81 = v7;
    *(char*)0xa0013b82 = (char)v5;
    *(char*)0xa0013b83 = (char)v11;
    *(char*)0xa0013b84 = (char)((v2 & 116) != 0);
    return -0x5ffec4c0;
  lab_0x1d01f754:
    // 0x1d01f754
    if (*(char*)0xa0013b70 != 0) {
        // 0x1d01f760
        if ((v10 | v6) % 256 == 0 == (*(char*)0xa0013b80 != 0)) {
            // 0x1d01f77c
            if (*(char*)0xa0013b51 == 0) {
                // 0x1d01f788
                if (*(char*)0xa0013b69 == 0) {
                    // 0x1d01f794
                    if (*(char*)0xa0013b81 == 0) {
                        char v14 = *(char *)(v3 - 0x7f8b); // 0x1d01f7a4
                        if (v9 == 0 != (*(int32_t *)(v3 - 0x7f88) == 0 || v14 == 1)) {
                            // 0x1d01f7bc
                            if (function_1d01b4a0() == 0) {
                                // 0x1d01f7cc
                                *(char*)0xa0013b71 = 1;
                                *(char *)(v3 - 0x7fe4) = 0;
                                int32_t * v15 = (int32_t *)(v3 - 0x7f90); // 0x1d01f7d8
                                if (*v15 == 0) {
                                    // 0x1d01f7e4
                                    *v15 = 1;
                                    *(int32_t *)(v3 - 0x7f98) = 13;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    goto lab_0x1d01f7f0;
}

// Address range: 0x1d01f8a8 - 0x1d01f8b0
int32_t function_1d01f8a8(void) {
    // 0x1d01f8a8
    int32_t v1; // 0x1d01f8a8
    return *(int32_t *)(v1 - 0x7f90);
}

// Address range: 0x1d01f8d4 - 0x1d01f8f8
int32_t function_1d01f8d4(void) {
    // 0x1d01f8d4
    int32_t v1; // 0x1d01f8d4
    int32_t v2 = *(int32_t *)(v1 - 0x7f90); // 0x1d01f8d4
    int32_t result = 1; // 0x1d01f8dc
    if (v2 != 0) {
        // 0x1d01f8e0
        result = v2 == 1 ? (int32_t)*(char *)(v1 - 0x7fe4) : 0;
    }
    // 0x1d01f8f0
    return result;
}

// Address range: 0x1d021a3c - 0x1d021a50
int32_t function_1d021a3c(void) {
    // 0x1d021a3c
    return (int32_t)*(char*)0xa00138e6;
}

// Address range: 0x1d025014 - 0x1d0251ac
int32_t pthread_cond_destroy5(void) {
    // 0x1d025014
    int32_t v1; // 0x1d025014
    char * v2 = (char *)(v1 - 0x7ef4); // 0x1d025014
    if (*v2 % 32 != 1) {
        // 0x1d0251a4
        return 1;
    }
    char result = *(char *)(v1 - 0x7ef0); // 0x1d025028
    if (result != 0) {
        // 0x1d0251a4
        return result;
    }
    char * v3 = (char *)(v1 - 0x7ef3); // 0x1d025038
    if (*v3 == 6) {
        // 0x1d02504c
        switch (*(char *)(v1 - 0x7ef1)) {
            case 33: {
                // 0x1d025070
                if (*(char *)(v1 - 0x7f04) == 1) {
                    // 0x1d025084
                    *(int32_t*)0xa0000480 = -0x62fd9e92;
                    *(int16_t *)-0x5ffffb78 = 9;
                    *(char*)0xa0000484 = -64;
                }
                // break -> 0x1d0250cc
                break;
            }
            case 34: {
                // 0x1d0250ac
                *(int32_t*)0xa0000480 = -0x62fd9ee8;
                *(int16_t *)-0x5ffffb78 = 29;
                *(char*)0xa0000484 = -64;
                // break -> 0x1d0250cc
                break;
            }
        }
    }
    // 0x1d0250cc
    if ((*v2 & 96) != 32) {
        // 0x1d0251a4
        return 32;
    }
    unsigned char result4 = *v3; // 0x1d0250e0
    if (result4 == 3) {
        // 0x1d025168
        *(int32_t*)0xa0000480 = v1 - 0x7eb3;
        *(int16_t *)-0x5ffffb78 = 1;
        *(char*)0xa0000484 = -127;
        return -0x5ffffb80;
    }
    if (result4 < 4) {
        // 0x1d0250fc
        if (result4 != 2) {
            // 0x1d025108
            return -0x60000000;
        }
        // 0x1d025128
        *(int32_t*)0xa0000480 = v1 - 0x7eb4;
        *(int16_t *)-0x5ffffb78 = 1;
        *(char*)0xa0000484 = -63;
        return -0x5ffffb80;
    }
    // 0x1d025110
    switch (result4) {
        case 10: {
            // 0x1d02514c
            *(char*)0xa0000484 = -128;
            unsigned char result2 = *(char *)(v1 - 0x7ef1); // 0x1d02515c
            *(char *)(v1 - 0x7eb4) = result2;
            return result2;
        }
        case 11: {
            // 0x1d025190
            *(char*)0xa0000484 = -128;
            char result3 = *(char *)(v1 - 0x7ef2); // 0x1d02519c
            *(char *)(v1 - 0x7eb3) = result3;
            // 0x1d0251a4
            return result3;
        }
    }
    // 0x1d025108
    return result4;
}

// Address range: 0x1d0252b0 - 0x1d0252d8
int32_t function_1d0252b0(int32_t a1, int32_t a2) {
    // 0x1d0252b0
    int32_t v1; // 0x1d0252b0
    int32_t result = *(int32_t *)(4 * a1 - 0x7fbc + v1) + 64 * a2; // 0x1d0252c4
    *(int32_t *)(result + 856) = 8;
    return result;
}

// Address range: 0x1d0252fc - 0x1d025340
int32_t function_1d0252fc(int32_t a1, int32_t a2) {
    // 0x1d0252fc
    int32_t v1; // 0x1d0252fc
    int32_t v2 = *(int32_t *)(4 * a1 - 0x7fbc + v1) + 64 * a2; // 0x1d025310
    if (__asm_ext(*(int32_t *)(v2 + 864), 10, 1) == 0) {
        // 0x1d025338
        return 0;
    }
    // 0x1d025324
    return *(int32_t *)(v2 + 880) | -0x60000000;
}

// Address range: 0x1d0263fc - 0x1d026424
int32_t function_1d0263fc(int32_t a1, int32_t a2) {
    // 0x1d0263fc
    int32_t v1; // 0x1d0263fc
    int32_t result = *(int32_t *)(4 * a1 - 0x7fbc + v1) + 64 * a2; // 0x1d026410
    *(int32_t *)(result + 856) = 0x2000;
    return result;
}

// Address range: 0x1d026f90 - 0x1d026f98
int32_t exit2(void) {
    // 0x1d026f90
    int32_t result; // 0x1d026f90
    __asm_di(result);
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected functions: 28
